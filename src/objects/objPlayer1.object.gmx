<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objPlayer</parentName>
  <maskName>sprPlayerHitbox</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Inherit events
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle ship movement
var movingVert;
var movingHoriz;

if (HP&lt;=0) {dead = true;}

//Explode ship if dead
if (dead)
{
    //if global.state&gt;3{global.state = 2;} //Force un-pause the game if we're paused for some reason

    if (!explode)
    {
        audio_stop_all();
        audio_play_sound(sfxDie,0,false);
        deadTimer = 4*deadTimerMult+deadWaitTime;
        explode = true;
    }
    if deadTimer&gt;-1 {deadTimer--;}
    if deadTimer&lt;=-1
    {
        global.playerLives--;
        if (global.playerLives&gt;=0)
        {
            resetRoom(); //Reset the room to how it originally was (the player still remembers how far they got in the level though)
            //Switch back to "START" screen
            deadTimer=0;
            explode = false;
            global.state = states.startRoom;
            objMain.startRoomTimer = objMain.startRoomTimerLength;
        }
        else
        {
        var gameOverString = "Game Over!";
        if ((global.playerScore &gt;= global.highScore &amp;&amp; (objMain.currPlayers&lt;=1)) || (global.playerScore &gt;= global.highCoScore &amp;&amp; (objMain.currPlayers&gt;=2)))
        {
            gameOverString += "##New highscore for ";
            {
                if objMain.currPlayers&lt;=1
                {
                    gameOverString += "Single Player!#Your Score: " + string(global.highScore);
                    ini_open("sav");
                    ini_write_string("Game Data","HiScore",string(global.highScore));
                    ini_close();
                }
                else
                {
                    gameOverString += "Multiplayer Co-Op!#Your Score: " + string(global.highCoScore);
                    ini_open("sav");
                    ini_write_string("Game Data","HiCoScore",string(global.highCoScore));
                    ini_close();
                }
            }   
        }
        show_message(gameOverString);
            global.playerLives = 2;
            global.konCodeLimit = 3;
            global.playerScore = 0;
            game_restart();}
    } //Timer hit zero. Now, we switch back to the START screen.
}
    //Account for camera scrolling before we move the player at all
    //Player and capsule-grabbing hitbox will keep scrolling with the camera even if they're dead
    
    if global.state != states.startRoom
    {
        x+=objCamera.scrollX;
        y+=objCamera.scrollY;
    }

if (!dead &amp;&amp; (global.state == states.gameMode || global.state == states.cutscene)) //Check if the player is still alive
{    
    //----Handle player movement
    //Check if we're moving vertically. Cancel out Up+Down
    if objMain.keyP1Up &amp;&amp; !objMain.keyP1Down
    {
    movingVert=1;
    }
    else if objMain.keyP1Down &amp;&amp; !objMain.keyP1Up
    {
    movingVert=-1;
    }
    else
    {
    movingVert=0;
    }
    
    //Do the same for horizontal movement, separately.
    if objMain.keyP1Left &amp;&amp; !objMain.keyP1Right
    {
    movingHoriz=-1;
    }
    else if objMain.keyP1Right &amp;&amp; !objMain.keyP1Left
    {
    movingHoriz=1;
    }
    else
    {
    movingHoriz=0;
    }

    //----Now that we know which direction to move in, check wall collisions and move the player
    touchingWall = false; //We're not touching a wall unless we detect that we are, which will change before we move the player
    
    //Determine diagonal movement
    var halveMovement = 1;
    if (movingHoriz!=0 &amp;&amp; movingVert !=0)
    {
        halveMovement = 2; //Divide our speed in half if we're moving diagonally
                            //Otherwise, just divide by 1, leaving the speed untouched
    }
    halveMovement=1;
    
    hsp = playerSpeed*movingHoriz/halveMovement;
    vsp = -(playerSpeed*movingVert/halveMovement);
    
    //Kill if the player hits a wall or enemy bullet within the level
    
    if (x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;=global.mapWidth*global.tileWidth &amp;&amp; y&lt;=global.mapHeight * global.tileHeight)
    {
        if (placeMeeting(hsp,0,"solid") || placeMeeting(0,vsp,"solid"))
        {
            if (!objCamera.debug)
            {
                if HP&gt;1
                {
                    audio_stop_sound(sfxBarrierWeaken);
                    audio_play_sound(sfxBarrierWeaken,0,false);
                }
                HP--;
            }
        }
    }
    
    //Check for camera walls and move the player, vertical and horizontal handled separately
    //Horizontal Collision
    if (x+hsp &lt;= objCamera.x+objCamera.leftBound)
    {
        //Left collision
        while(x-1 &gt; objCamera.x+objCamera.leftBound)
        {
            x-=1;
        }
        hsp = 0;
    }
    if (x+hsp &gt;= objCamera.x+objCamera.viewportWidth-objCamera.rightBound)
    {
        //Right collision
        while(x+1 &lt; objCamera.x+objCamera.viewportWidth-objCamera.rightBound)
        {
            x+=1;
        }
        hsp = 0;
    }
    
    //Vertical Collision
    if (y+vsp &lt;= objCamera.y+objCamera.upperBound)
    {
        //Ceiling collision
        while(y-1 &gt; objCamera.y+objCamera.upperBound)
        {
            y-=1;
        }
        vsp = 0; touchingWall=true;
    }
    if (y+vsp &gt;= objCamera.y+objCamera.viewportHeight-objCamera.lowerBound)
    {
        //Floor collision
        while(y+1 &lt; objCamera.y+objCamera.viewportHeight-objCamera.lowerBound)
        {
            y+=1;
        }
        vsp = 0;
    }
    x += hsp;
    y += vsp;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move the hitbox
for (var i=0; i&lt;instance_number(objPlayerCapsuleHitbox); i++)
{
    thisHitbox = instance_find(objPlayerCapsuleHitbox, i);
    if (thisHitbox.myPlayer==1)
    {
        thisHitbox.x = x;
        thisHitbox.y = y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle powerups
//The HUD itself is drawn in objCamera's Draw Event

if (objCamera.debug)
{
    if keyboard_check_pressed(ord('T'))
    {
        powerupSlot+=1; //Give us a powerup capsule if we press T on the keyboard
    }
    if (keyboard_check_pressed(ord('U')))
    {
        konDone = false;
        konCode = true;
    }
    
    if (keyboard_check_pressed(ord('G')))
    {
        global.playerScore += 500;
    }
    if (keyboard_check_pressed(ord('B')))
    {
        dead = true;
    }
    if (keyboard_check_pressed(ord('I')))
    {
        if (playerSpeed&lt;playerSpeedMax)
            {
            playerSpeed+=1; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
    }
    if (keyboard_check_pressed(ord('O')))
    {if instance_exists(objFrontShield){objFrontShield.HP--;}}
}

if (konCode &amp;&amp; !konDone &amp;&amp; (konCodeLimit&gt;0 || callD&gt;0))
{
    hasMissile = true;
    hasDouble = false;
    hasLaser = true;
    while(numOfOpts&lt;optsMax) //Continue to give the player an Option until they've hit the max
    {
        instance_create(-5000,-5000,objOption); //Spawn a new Option far away
        numOfOpts+=1;
    }
    
    if instance_exists(objFrontShield)
    {
        with(objFrontShield)
        {instance_destroy();}
    }
    hasQuestion = true;
    shield1 = instance_create(objCamera.x+288,objCamera.y-32,objFrontShield);
    shield1.xDest = 16;
    shield1.yDest = -8;
    shield2 = instance_create(objCamera.x+288,objCamera.y+objCamera.viewportHeight+32,objFrontShield);
    shield2.xDest = 16;
    shield2.yDest = 8;
    konDone = true;
}

if (objMain.shieldType==0 &amp;&amp; instance_number(objFrontShield)&lt;=0)
{
    hasQuestion = false;
}
else if (objMain.shieldType==1 &amp;&amp; HP &lt;= 1)
{
    hasQuestion = false;
}

//Wrap around if we go too far beyond the powerup HUD
if (objMain.currPlayers&lt;=1)
{
    if (powerupSlot&gt;7)
    {
        powerupSlot = 1;
    }
}
else
{
    if (powerupSlot&gt;6) //Disable Exclamation if we're on multiplayer
    {
        powerupSlot = 1;
    }
}

//Mega crash only needs one frame, then it's disabled again
hasExclamation = false;

if objMain.keyP1Action2 &amp;&amp; !dead &amp;&amp; (objCamera.debug || global.state=states.gameMode)  //Attempt to give powerup after pressing equip button
{
    switch(powerupSlot) //Check the value of our powerup's position and, depending what it is, try giving a powerup
    {
        case 1: //Speedup
            if (playerSpeed&lt;playerSpeedMax)
            {
            playerSpeed+=1;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 2: //Missile
            if (!hasMissile)
            {
            hasMissile = true;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 3: //Double
            if (!hasDouble)
            {
            hasDouble = true;
            hasLaser = false;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 4: //Laser
            if (!hasLaser)
            {
            hasLaser = true;
            hasDouble = false;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 5: //Option
            if (numOfOpts&lt;optsMax)
            {
            numOfOpts+=1;instance_create(-5000,-5000,objOption); //Spawn a new Option far away
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 6: //Question
            if (!hasQuestion)
            {
                if (objMain.shieldType==0) //Standard Shield
                {
                    hasQuestion = true;
                    shield1 = instance_create(objCamera.x+288,objCamera.y-32,objFrontShield);
                    shield1.xDest = 16;
                    shield1.yDest = -8;
                    shield2 = instance_create(objCamera.x+288,objCamera.y+objCamera.viewportHeight+32,objFrontShield);
                    shield2.xDest = 16;
                    shield2.yDest = 8;
                    powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
                }
                else if (objMain.shieldType==1) //Force Field
                {
                    hasQuestion = true;
                    if (global.frModeEnabled)
                    {
                        HP = 11;
                        HPMax = 11; //HP Max is for objCamera to know how to properly scale the Force Field image
                    }
                    else
                    {
                        HP = 6;
                        HPMax = 6;
                    }
                    powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
                }
            }
            break;
        case 7: //Exclamation
            if (!hasExclamation)
            {
            hasExclamation = true;
            excTimer = 10;
            powerupSlot = 0; audio_stop_sound(sfxMCrash); audio_play_sound(sfxMCrash,0,false);
            }
            break;
        default: break;
    }
}

if (excTimer&gt;0){excTimer--;}

if (callD&gt;0){fun=true;}
if (global.state==states.gameMode)
{
    if (callD&gt;-1 &amp;&amp; fun){callD--;}
    if (callD&lt;=-1){dead=true;}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle ship animations and Options movement
if (!dead &amp;&amp; (global.state == states.gameMode || global.state == states.cutscene)) //Check if the player is still alive
{
    //Set the ship back to neutral position if our player isn't moving vertically or is touching a wall.
    //shipTurning is the ship-tilting animation
    
    if ((touchingWall) || (movingVert==0))
    {
        if(shipTurning&gt;0){if shipTurning-playerSpeed&gt;0{shipTurning-=playerSpeed;}else{shipTurning=0;}}
        else if(shipTurning&lt;0){if shipTurning+playerSpeed&lt;0{shipTurning+=playerSpeed;}else{shipTurning=0;}}
    }
    

    //Now we'll let the ship tilt its animation as it moves, but only if it isn't touching a wall (e.g. Camera's screen boundary)
    if(!touchingWall)
    {
        if (movingVert==-1) //Handle downward animation first
        {
            if (shipTurning-playerSpeed&lt;0)
            {
            shipTurning-=playerSpeed;
            }
            else
            {shipTurning=0;}
        }
        else if (movingVert==1)                //Now, handle the upward animation
        {
            if (shipTurning+playerSpeed&gt;0)
            {
            shipTurning+=playerSpeed;
            }
            else
            {shipTurning=0;}   
        }
    }

    //Cap values
    if (shipTurning&lt;-8*turnMult){shipTurning=-8*turnMult;}
    if (shipTurning&gt;8*turnMult){shipTurning=8*turnMult;}
    
    //Handle ship animations
    if (shipTurning &lt;-4*turnMult){image_index=4;} //Downmost
    else if (shipTurning&gt;=-4*turnMult &amp;&amp; shipTurning &lt;0){image_index=3;} //Slight Down
    else if (shipTurning&gt;0 &amp;&amp; shipTurning &lt;=4*turnMult){image_index=1;} //Slight Up
    else if (shipTurning&gt;4*turnMult){image_index=2;} //Upmost 
    else {image_index=0;} //Every other case is neutral position


    if (objMain.keyP1Right || 
        objMain.keyP1Left || 
        objMain.keyP1Up || 
        objMain.keyP1Down) //If the player is moving at all...
    {

    //GRV-Style Option Movement code
    if (objMain.keyP1Action3 &amp;&amp; global.grVOptEnabled) //Are we pushing the Option button and is the feature enabled?
    {
        if (hsp!=0)
        {
        for (var i = 39; i &gt;= 0; i--;)  //Shift all 40 frames of x/y ghost trailing by however the player moved
           {
           prevX[i] += hsp;
           }
        }
        if (vsp!=0)
        {
        for (var i = 39; i &gt;= 0; i--;)  //Shift all 40 frames of x/y ghost trailing by however the player moved
           {
            prevY[i] += vsp;
            }
        }
    }
    else //If not, we should keep track of the player's x/y positions for the past 40 frames of the game in the two arrays prevX and prevY, constantly.
    {
        //Shift all the X/Y previous positions down the bank
        for (var i = 39; i &gt; 0; i--;)
           {
           prevX[i] = prevX[i-1];
           prevY[i] = prevY[i-1];
           }
        //Finally, store X/Y in the first position
        prevX[0] = x+hsp;
        prevY[0] = y+vsp;
        }
    }

    
    //Regardless we're moving or not, update every single X/Y ghost position with the camera scrolling
    for (var i = 39; i &gt;= 0; i--;)
       {
       prevX[i] += objCamera.scrollX;
       prevY[i] += objCamera.scrollY;
       }

    
    //Handle the flame burning animation index at the end of the ship, based on our player's speed
    
    var flameImgOut=0; //Temporary variable for storing animation index before actually outputting it to the screen
    
    if (global.tick%flameSpeed==0) //Hop between animation frames (lazily using a boolean) so the fire looks more lively
    {
        flameIn = !flameIn;
    }
    
    switch(playerSpeed) //Determine the first frame of the flame animation, depending on the player's speed
    {
        case 1: flameImgOut=0; break; //In the event that the playerSpeed is 1, start our animation on frame 0
        case 2: flameImgOut=2; break; //etc...
        case 3: flameImgOut=2; break;
        case 4: flameImgOut=4; break;
        case 5: flameImgOut=4; break;
        default: flameImgOut=4; break; //In the event our player speed is some weird value, default to frame 4
    }
    
    flameImgOut+=flameIn;
    
    flameImgInd=flameImgOut; //Finally, we store the flame animation, which is then drawn in objCamera's Draw event
    
    //Force Field animation (the rest is handled in objCamera's Draw Event)
    if (global.tick%forceFrameSpeed==0)
    {
        forceFrame = (!forceFrame) * objMain.deltaTime; //Multiply by deltaTime to account for game pausing
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Let's shooting!
if (!dead &amp;&amp; (global.state == states.gameMode || global.state == states.cutscene)) //Check if the player is still alive
{
    shootingScript(1,self);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
