<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize some variables
depth=1000000;

debug=false;
camMoveSpeed=4;
tilemapViewportWidth=288;
tilemapViewportHeight=288;
//Always leave these at 0
scrollX=0.3;
scrollY=0;
prevScrollX = 0.3;
prevScrollY = 0;

//Reserved for recalling the previous scroll rate upon pausing/cutscene triggers
scrollXPrevious=0;
scrollYPrevious=0;
pauseFlickerOn = false;
//Reserved for drawing "START" on the screen in objCamera's draw event
startFlickerOn=false;
startWaitTimer=0;

//Screen borders
leftBound=16;
rightBound=16;
upperBound=28;
lowerBound=32;
viewportWidth=256;
viewportHeight=256;

//Cutscene bars
yCutsceneBarTo=0;
yCutsceneBarPos=-32;

//Force background to where this camera is
background_x[0] = objCamera.x+objMain.bg0XParallax;
background_x[1] = objCamera.x+objMain.bg1XParallax;
background_x[2] = objCamera.x+objMain.bg2XParallax;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug moving camera
//Uses WASD but UDLR if WASD is occupied

var movingVert;
var movingHoriz;

if (objMain.debugEnabled)
{
    if (keyboard_check_pressed(ord('Q')))
    {
    debug = !debug;
    }
}

if (debug)
{

if keyboard_check_pressed(ord('P')){exportLevel()};
    
    if (keyboard_check_pressed(ord('R')))
    {
    scrollX = 0.3;
    }
    if (keyboard_check_pressed(vk_add))
            {
            global.playerLives++;
            }
    if (keyboard_check_pressed(vk_subtract))
            {
            global.playerLives--;
            }

if (keyboard_check(global.cameraUp) &amp;&amp; global.cameraUp != global.keyUp) || (keyboard_check(vk_up) &amp;&amp; global.cameraUp == global.keyUp)
{
movingVert=1;
}
else if (keyboard_check(global.cameraDown) &amp;&amp; global.cameraDown != global.keyDown) || (keyboard_check(vk_down) &amp;&amp; global.cameraDown == global.keyDown)
{
movingVert=2;
}
else
{
movingVert=0;
}

if (keyboard_check(global.cameraLeft) &amp;&amp; global.cameraLeft != global.keyLeft) || (keyboard_check(vk_left) &amp;&amp; global.cameraLeft == global.keyLeft)
{
movingHoriz=1;
}
else if (keyboard_check(global.cameraRight) &amp;&amp; global.cameraRight != global.keyRight) || (keyboard_check(vk_right) &amp;&amp; global.cameraRight == global.keyRight)
{
movingHoriz=2;
}
else
{
movingHoriz=0;
}

    switch(movingVert)
    {
    case 1: y-=camMoveSpeed;break; //up
    case 2: y+=camMoveSpeed;break; //down
    default: break;
    }
    
    switch(movingHoriz)
    {
    case 1: x-=camMoveSpeed;break; //left
    case 2: x+=camMoveSpeed;break; //right
    default: break;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement code

//Every frame, we should check for any level events (bgm changing, map switching, etc)
levelEvents();

//We should also have the background follow the camera.
background_x[0] = objCamera.x+objMain.bg0XParallax;
background_x[1] = objCamera.x+objMain.bg1XParallax;
background_x[2] = objCamera.x+objMain.bg2XParallax;

if (global.state==states.gameMode)
{
x += scrollX;
y += scrollY;
}

view_xview = objCamera.x;
view_yview = objCamera.y;

objMain.bg0XParallax+=background_hspeed[0];
objMain.bg1XParallax+=background_hspeed[1];
objMain.bg2XParallax+=background_hspeed[2];

background_x[0] = x+objMain.bg0XParallax;
background_x[1] = x+objMain.bg1XParallax;
background_x[2] = x+objMain.bg2XParallax;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing layer 1
draw_enable_alphablend(true);
if (global.state==2 || global.state==3 || global.state==5)
{
    if (ds_exists(objMain.levelData,ds_type_grid))
    {    
    
    
    //dynamic render
    var startCol = floor(objCamera.x / global.tileWidth)-1;
    var endCol = startCol + (objCamera.tilemapViewportWidth / global.tileWidth);
    var startRow = floor(objCamera.y / global.tileHeight)-1;
    var endRow = startRow + (objCamera.tilemapViewportHeight / global.tileWidth);
    
    var offsetX = startCol * global.tileWidth;
    var offsetY = startRow * global.tileHeight;
    
    
    for (var c = startCol; c &lt;= endCol; c++)
    {
        for (var r = startRow; r &lt;= endRow; r++)
        {
            
            if (c&gt;=0 &amp;&amp; c&lt;(global.mapWidth) &amp;&amp; r&gt;=0 &amp;&amp; r&lt;(global.mapHeight))
            {
            var tileID = ds_grid_get(objMain.levelData, c, r);
            }
            else {tileID=0;}
            
            if (tileID&lt;0 || tileID&gt;255)
                {tileID=0;}
                
                var xPos = round((c - startCol) * global.tileWidth + offsetX);
                var yPos = round((r - startRow) * global.tileHeight + offsetY);
    
            if (tileID!=0)
                {
                draw_background_part(
                global.tilesetIndex, // image
                getTile(real(tileID),3), // source x
                getTile(real(tileID),4), // source y
                global.tileWidth, // source width
                global.tileHeight, // source height
                xPos,// target x
                yPos // target y
                );//depth
                
                }
        }
    }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw sprites under player

if (global.state != states.startRoom)
{
    drawSprites(objBossLaser,sprBossLaser);
    drawSprites(objBoss1,sprBoss1);
    drawSprites(objBossEye,sprBossEye);
    drawSprites(objBossBarrier,sprBossBarrier);
    drawSprites(obj16x16Explosion,spr16x16Explosion);
    drawSprites(objCapsule,sprCapsule);
    drawSprites(objMissile,sprMissile);
    drawSprites(objBullet,sprBullet);
    drawSprites(objDouble,sprDouble);

    draw_enable_alphablend(false);
    drawLaser();
    draw_enable_alphablend(true);
    
    //Loop through every single instance of the Option and draw them one by one
    if instance_exists(objOption)
        {
            var i;
            for (i = 0; i &lt; instance_number(objOption); i += 1)
               {
                thisOption = instance_find(objOption,i);
                with (thisOption)
                    {
                    if (enabled)
                        {
                        draw_sprite(sprOption,image_index,x,y);
                        }
                    }
    
               }
        }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the player


if global.state!=4
{


if (instance_exists(objPlayer))
{
    if (!objPlayer.dead)
    {
    
    draw_sprite(sprPlayer,objPlayer.image_index,objPlayer.x,objPlayer.y-1);
    draw_sprite(sprPlayerFlame,objPlayer.flameImgInd,objPlayer.x-16,objPlayer.y);
    }
    else
    {
        with(objPlayer)
            {
            if (deadTimer&gt;4*deadTimerMult+deadWaitTime){image_index=4;}
            if (deadTimer&gt;3*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=4*deadTimerMult+deadWaitTime){image_index=3;}
            if (deadTimer&gt;2*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=3*deadTimerMult+deadWaitTime){image_index=2;}
            if (deadTimer&gt;1*deadTimerMult+deadWaitTime &amp;&amp; deadTimer&lt;=2*deadTimerMult+deadWaitTime){image_index=1;}
            if (deadTimer&gt;deadWaitTime &amp;&amp; deadTimer&lt;=1*deadTimerMult+deadWaitTime){image_index=0;}
            }
            
            if (objPlayer.deadTimer&gt;objPlayer.deadWaitTime)
            {
                draw_sprite(sprPlayerExplode,objPlayer.image_index,objPlayer.x,objPlayer.y-1);
            }
    }
    
    if (objCamera.debug)
        {
        draw_set_alpha(0.4);
        draw_sprite(sprPlayerCapsuleHitbox,0,objPlayerCapsuleHitbox.x,objPlayerCapsuleHitbox.y);
        draw_set_alpha(0.7);
        draw_sprite(sprPlayerHitbox,0,objPlayer.x,objPlayer.y);
        draw_set_alpha(1);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw sprites over player
//Draw front shields
if (global.state != states.startRoom)
{
    if instance_exists(objFrontShield)
        {
            var i;
            for (i = 0; i &lt; instance_number(objFrontShield); i += 1)
               {
                thisObject = instance_find(objFrontShield,i);
                with (thisObject)
                    {
                    draw_sprite_ext(sprFrontShield,image_index,x,y,image_xscale, image_yscale,0,c_white,1);
                    }
    
               }
        }
    drawSprites(objEnemyBullet,sprEnemyBullet);
    drawSprites(objDee01,sprDee01);
    drawSprites(objLion,sprLion);
    drawSprites(objBean,sprBean);
    drawSprites(objBigExplosion,sprBigExplosion);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing overlay layer

if (global.state==2 || global.state==3 || global.state==5)
{
    if (ds_exists(objMain.levelDataLayer2,ds_type_grid))
    {
    
    //dynamic render
    var startCol = floor(objCamera.x / global.tileWidth)-1;
    var endCol = startCol + (objCamera.tilemapViewportWidth / global.tileWidth);
    var startRow = floor(objCamera.y / global.tileHeight)-1;
    var endRow = startRow + (objCamera.tilemapViewportHeight / global.tileWidth);
    
    var offsetX = startCol * global.tileWidth;
    var offsetY = startRow * global.tileHeight;
    
    
    for (var c = startCol; c &lt;= endCol; c++)
    {
        for (var r = startRow; r &lt;= endRow; r++)
        {
            
            if (c&gt;=0 &amp;&amp; c&lt;(global.mapWidth) &amp;&amp; r&gt;=0 &amp;&amp; r&lt;(global.mapHeight))
            {
            var tileID = ds_grid_get(objMain.levelDataLayer2, c, r);
            }
            else {tileID=0;}
            
            if (tileID&lt;0 || tileID&gt;255)
                {tileID=0;}
                
                var xPos = round((c - startCol) * global.tileWidth + offsetX);
                var yPos = round((r - startRow) * global.tileHeight + offsetY);
    
            if (tileID!=0)
                {
                draw_background_part(
                global.tilesetIndex, // image
                getTile(real(tileID),3), // source x
                getTile(real(tileID),4), // source y
                global.tileWidth, // source width
                global.tileHeight, // source height
                xPos,// target x
                yPos // target y
                );//depth
                
                }
        }
    }
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle the START before the player gains control and pause text

if (global.tick%17==2 &amp;&amp; startWaitTimer&lt;=0)
    {startFlickerOn=!startFlickerOn; startWaitTimer=5;}
if startWaitTimer&gt;0{startWaitTimer--;}

if (global.state==states.startRoom)
{
    draw_set_color(c_black);
    draw_rectangle(objMain.x-16,objMain.y-16,objMain.x+viewportWidth+16,objMain.y+viewportHeight+16,false);
    
    if (startFlickerOn)
    {
    draw_sprite(sprStart,0,objMain.x+(viewportWidth/2),objMain.y+(viewportHeight/2)-8); //Arcade Style
    //draw_set_color(c_white);
    //draw_text(objMain.x+(viewportWidth/2)-(8*2),objMain.y+(viewportHeight/2)-(8*2),"START"); //SNES Style
    }
}

if (global.tick%40==2)
    {pauseFlickerOn=!pauseFlickerOn;}


if (global.state==states.paused)
{
    draw_enable_alphablend(true);
    draw_set_color(c_white);
    
    if (pauseFlickerOn)
    {
    draw_text(x+(viewportWidth/2)-(8*3),y+(viewportHeight/2)-(8*2),"PAUSED"); //SNES Style
    }
}

if (global.state==states.gameMode &amp;&amp; objMain.showLoop&gt;0)
{
    draw_enable_alphablend(true);
    draw_set_color(c_white);
    
    
    draw_text(x,y+(viewportHeight/2)-(8*3),"    Congratulations! Now try");
    if (pauseFlickerOn)
    {
    draw_text(x+(viewportWidth/2)-(8*3),y+(viewportHeight/2)-(8*2),"Loop " + string(objMain.loopCounter) + "!");
    }
    
    objMain.showLoop--;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the Powerup HUD
draw_enable_alphablend(false);
if (global.state==states.gameMode ||
    global.state==states.cutscene ||
    global.state==states.startRoom ||
    global.state==states.paused)
{
    for(var i=0;i&lt;7;i++)
    {
        //Handle the boxes themselves
        if (i+1 == objPlayer.powerupSlot)
        {
        //original y pos was 212
        draw_sprite(sprPowerupHUD,1,objCamera.x+16+(32*i),objCamera.y+228);
        }
        else
        {draw_sprite(sprPowerupHUD,0,objCamera.x+16+(32*i),objCamera.y+228);}
    }
    
    //Handle the actual text in the boxes
    draw_enable_alphablend(true);
    var currColor = c_white;
    //Speedup
    currColor = hudDetermineColor(1); if (objPlayer.playerSpeed &lt; objPlayer.playerSpeedMax) draw_sprite_ext( sprPowerupHUD, 2, objCamera.x+16+(32*0),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Missile
    currColor = hudDetermineColor(2); if (!objPlayer.hasMissile) draw_sprite_ext( sprPowerupHUD, 3, objCamera.x+16+(32*1),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Double
    currColor = hudDetermineColor(3); if (!objPlayer.hasDouble) draw_sprite_ext( sprPowerupHUD, 4, objCamera.x+16+(32*2),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Laser
    currColor = hudDetermineColor(4); if (!objPlayer.hasLaser) draw_sprite_ext( sprPowerupHUD, 5, objCamera.x+16+(32*3),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Option
    currColor = hudDetermineColor(5); if (objPlayer.numOfOpts&lt;objPlayer.optsMax) draw_sprite_ext( sprPowerupHUD, 6, objCamera.x+16+(32*4),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Question
    currColor = hudDetermineColor(6); if (!objPlayer.hasQuestion) draw_sprite_ext( sprPowerupHUD, 7, objCamera.x+16+(32*5),objCamera.y+228, 1, 1, 0, currColor, 1);
    //Exclamation
    currColor = hudDetermineColor(7); if (!objPlayer.hasExclamation) draw_sprite_ext( sprPowerupHUD, 8, objCamera.x+16+(32*6),objCamera.y+228, 1, 1, 0, currColor, 1);
    
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the upper HUD
draw_enable_alphablend(true);
draw_set_color(c_white);
//Calculate the spacing between "P1" and the score location
var dynamicPlayerScoreSpacing="";
var lenPlayerScore = string_length(string(global.playerScore));
for(var i=0; i&lt;13-lenPlayerScore;i++)
{
    dynamicPlayerScoreSpacing+=" ";
}

//Calculate the spacing between "HI" and the score location
var dynamicHighScoreSpacing="";
var lenHighScore = string_length(string(global.highScore));
for(var i=0; i&lt;13-lenHighScore;i++)
{
    dynamicHighScoreSpacing+=" ";
}

//Finally, draw the score onto the screen

draw_text(objCamera.x,objCamera.y+4,"1P" + dynamicPlayerScoreSpacing + string(global.playerScore));
draw_text(objCamera.x+(8*16),objCamera.y+4,"HI" + dynamicHighScoreSpacing + string(global.highScore));

//Next, draw the lives
var livesDispNum = global.playerLives; //The number of lives to show on the screen
var livesText = "";

if (global.playerLives&gt;9)
{
//We only want to draw 9 on the screen at a time (the last life isn't displayed), so use modulo (%) to display the remainder of lives after division
livesDispNum = global.playerLives%10;
}

//After we found out how many lives we're supposed to draw on the screen, do so using ~ in sprFont to represent each life

for (var i=0; i&lt;livesDispNum;i++)
{
    livesText+="~";
}

//By the way, 0 is the last life before a game over, not 1.
draw_text(objCamera.x,objCamera.y+4,"# " + livesText);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Cutscene borders
draw_enable_alphablend(false);
var cutsceneBarMoveSpeed=4;

if global.state==2
{
    yCutsceneBarTo=-32;
    if yCutsceneBarPos&gt;yCutsceneBarTo
    {
        yCutsceneBarPos-=cutsceneBarMoveSpeed;
    }
}
else if global.state==3
{
    yCutsceneBarTo=0;
    if yCutsceneBarPos&lt;yCutsceneBarTo
    {
        yCutsceneBarPos+=cutsceneBarMoveSpeed;
    }
    else
    {
        //the cutscene is completely gone. restore the previous game state here
        
    }
    
}

draw_set_color(c_black);

//upper
draw_rectangle(x-8,y+yCutsceneBarPos-1,x+263,y+yCutsceneBarPos+31,false);
//lower
draw_rectangle(x-8,y+224-yCutsceneBarPos,x+263,y+223-yCutsceneBarPos+32,false);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle screen flashing
if (objPlayer.excTimer&gt;0)
{
    if (global.tick%2==0)
    {
        draw_enable_alphablend(false);
        draw_set_color(c_white);
        draw_rectangle(x-64,y-64,x+viewportWidth+64,y+viewportHeight+64,false);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug stuff
draw_enable_alphablend(true);

if (debug)
{
    
    var posX=floor(mouse_x/16);
    var posY=floor(mouse_y/16);
    var changeTile=false;

    draw_set_color(c_white);
    if (posX&lt;=global.mapWidth-1 &amp;&amp; posX&gt;=0) &amp;&amp; (posY&lt;=global.mapHeight-1 &amp;&amp; posY&gt;=0)
    {
    var tile = real(ds_grid_get(objMain.levelData,posX,posY));
    draw_text(objCamera.x,objCamera.y+4,"###Mouse on tile type: " + string(tile) + "(" + string(objMain.tiletypes[tile]) + ")");
    
    //Allow debug changing tile if you left/right-click over the tile. Cycle through the tiles.
    if mouse_check_button_pressed(mb_left) &amp;&amp; !mouse_check_button_pressed(mb_right){if tile&lt;255{tile++;}else{tile=0;} changeTile=true;}
    if mouse_check_button_pressed(mb_right) &amp;&amp; !mouse_check_button_pressed(mb_left){if tile&gt;0{tile--;}else{tile=255;} changeTile=true;}
    if keyboard_check(vk_shift) &amp;&amp; mouse_check_button(mb_right){tile=0;}
    if (changeTile){ds_grid_set(objMain.levelData,posX,posY,tile);}
    
    draw_set_color(c_green);
    }
    else{draw_text(objCamera.x,objCamera.y+4,"###Mouse on tile type: OoB");draw_set_color(c_red);}
    draw_set_alpha(0.3);
    draw_rectangle(posX*16,posY*16,posX*16+15,posY*16+15,false);
    draw_set_alpha(1);
    
    draw_set_color(c_white);
    draw_text(objCamera.x,objCamera.y+4,"#####FPS: " + string(fps)
    + "#Total entities: " + string(instance_count)
    + "#Game Loop: " + string(objMain.loopCounter));
    
    if global.state == 2
    {
        if keyboard_check_pressed(ord('E'))
        {
        global.state = 3;
        }
    }
    else if global.state == 3
    {
        if keyboard_check_pressed(ord('E'))
            {
            global.state = 2;
            }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle game closing text
draw_enable_alphablend(false);

    if (objMain.gameEndTimer&lt;40 &amp;&amp; objMain.gameEndTimer&gt;=30)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game");
    }
    else if (objMain.gameEndTimer&lt;30 &amp;&amp; objMain.gameEndTimer&gt;=20)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game.");
    }
    else if (objMain.gameEndTimer&lt;20 &amp;&amp; objMain.gameEndTimer&gt;=10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game..");
    }
    else if (objMain.gameEndTimer&lt;10)
    {
    draw_rectangle_color(x, y, x+159, y+8, c_black, c_black, c_black, c_black, false);
    draw_set_color(c_white);
    draw_text(x,y,"Closing the game...");
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
