<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerHitbox</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Code optimization attempt for in-game gameplay
draw_texture_flush();
draw_sprite(sprPlayer, 0, 0, 0);
draw_sprite(sprPlayerHitbox, 0, 0, 0);
draw_sprite(sprPlayerCapsuleHitbox, 0, 0, 0);
draw_sprite(sprOption, 0, 0, 0);
draw_sprite(sprLaser, 0, 0, 0);
draw_sprite(sprFrontShield, 0, 0, 0);
draw_sprite(sprFont, 0, 0, 0);
draw_sprite(sprDouble, 0, 0, 0);
draw_sprite(sprBullet, 0, 0, 0);
draw_sprite(tileset0, 0, 0, 0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize some variables
shootDelayTimer=0;
shootCounter=0;
shootCounterMaxWithoutDouble=2;
shootCounterMaxWithDouble=1;
shootCounterMax=shootCounterMaxWithoutDouble;
missileDelayTimer=0;
missileCounter=0;
missileCounterMax=2;
shootDoubleDelayTimer=0;
shootDoubleCounter=0;
shootDoubleCounterMax=1;

image_speed=0;
shipTurning=0;
flameImgInd=0;
touchingWall=false;
turnMult=5; //Multiplies how long it takes for the ship to turn
flameIn=true; //Flag for ship flame animation
flameSpeed=3; //Ship flame animation speed
movingVert = 0;
movingHoriz = 0;

//Death-related variables
dead = false;
deadTimer = 0;
explode = false;
deadTimerMult = 4;      //Delay between each animation frame
deadWaitTime = 55;     //How long we should wait after the death animation

//Powerup-related variables
konCode = false; // :)
konDone = false;
konCodeLimit = 3; //Per game-over
fun = false;
callD = 0;
cc1=0;
cc2=0;
powerupSlot = 0;
playerSpeed = 1;
playerSpeedMax = 6;
hasMissile = false;
hasDouble = false;
hasLaser = false;
laserCooldownTimer = 0;
numOfOpts = 0;
optsMax = 4;
hasQuestion = false;
hasExclamation = false;
excTimer = 0;

myID = 0; //Only used to distinguish between the player and each Option

//Initialize prevX/prevY arrays with the player's initial position, for player trailing
for (var i = 39; i &gt; 0; i--;)
       {
       prevX[i] = x;
       prevY[i] = y;
       }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle ship movement
var movingVert;
var movingHoriz;

//Explode ship if dead
if (dead)
{
    //if global.state&gt;3{global.state = 2;} //Force un-pause the game if we're paused for some reason

    if (!explode)
    {
    audio_stop_all();
    audio_play_sound(sfxDie,0,false);
    deadTimer = 4*deadTimerMult+deadWaitTime;
    explode = true;
    }
    if deadTimer&gt;-1 {deadTimer--;}
    if deadTimer&lt;=-1
    {
        global.playerLives--;
        if (global.playerLives&gt;=0)
        {
            resetRoom(); //Reset the room to how it originally was (the player still remembers how far they got in the level though)
            //Switch back to "START" screen
            deadTimer=0;
            explode = false;
            global.state = states.startRoom;
            objMain.startRoomTimer = objMain.startRoomTimerLength;
        }
        else
        {
        var gameOverString = "Game over, lol";
        if (global.playerScore &gt;= global.highScore)
        {
            gameOverString += "##New highscore!";
            {
            ini_open("sav");
            ini_write_string("Game Data","HiScore",string(global.highScore));
            ini_close();
            }   
        }
        show_message(gameOverString);
            global.playerLives = 2;
            global.konCodeLimit = 3;
            global.playerScore = 0;
            game_restart();}
    } //Timer hit zero. Now, we switch back to the START screen.
}
    //Account for camera scrolling before we move the player at all
    //Player and capsule-grabbing hitbox will keep scrolling with the camera even if they're dead
    
    if global.state != states.startRoom
    {
        x+=objCamera.scrollX;
        y+=objCamera.scrollY;
        objPlayerCapsuleHitbox.x+=objCamera.scrollX;
        objPlayerCapsuleHitbox.y+=objCamera.scrollY;
    }

if (!dead &amp;&amp; (global.state == 2 || global.state == 3)) //Check if the player is still alive
{    
    //----Handle player movement
    //Check if we're moving vertically. Cancel out Up+Down
    if keyboard_check(global.keyUp) &amp;&amp; !keyboard_check(global.keyDown)
    {
    movingVert=1;
    }
    else if keyboard_check(global.keyDown) &amp;&amp; !keyboard_check(global.keyUp)
    {
    movingVert=-1;
    }
    else
    {
    movingVert=0;
    }
    
    //Do the same for horizontal movement, separately.
    if keyboard_check(global.keyLeft) &amp;&amp; !keyboard_check(global.keyRight)
    {
    movingHoriz=-1;
    }
    else if keyboard_check(global.keyRight) &amp;&amp; !keyboard_check(global.keyLeft)
    {
    movingHoriz=1;
    }
    else
    {
    movingHoriz=0;
    }

    //----Now that we know which direction to move in, check wall collisions and move the player
    touchingWall = false; //We're not touching a wall unless we detect that we are, which will change before we move the player
    
    //Determine diagonal movement
    var halveMovement = 1;
    if (movingHoriz!=0 &amp;&amp; movingVert !=0)
    {
        halveMovement = 2; //Divide our speed in half if we're moving diagonally
                            //Otherwise, just divide by 1, leaving the speed untouched
    }
    halveMovement=1;
    
    hsp = playerSpeed*movingHoriz/halveMovement;
    vsp = -(playerSpeed*movingVert/halveMovement);
    
    //Kill if the player hits a wall or enemy bullet within the level
    
    if (x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;=global.mapWidth*global.tileWidth &amp;&amp; y&lt;=global.mapHeight * global.tileHeight)
    {
        if (placeMeeting(hsp,0,"solid") || placeMeeting(0,vsp,"solid"))
        {
            if (!objCamera.debug)
            {dead = true;}
        }
    }
    
    if (place_meeting(x,y,objEnemyBullet) || place_meeting(x,y,objBossLaser))
    {
        if (!objCamera.debug)
        {dead = true;}
    }
    
    //Check for camera walls and move the player, vertical and horizontal handled separately
    //Horizontal Collision
    if (x+hsp &lt;= objCamera.x+objCamera.leftBound)
    {
        //Left collision
        while(x-1 &gt; objCamera.x+objCamera.leftBound)
        {
            x-=1;
        }
        hsp = 0;
    }
    if (x+hsp &gt;= objCamera.x+objCamera.viewportWidth-objCamera.rightBound)
    {
        //Right collision
        while(x+1 &lt; objCamera.x+objCamera.viewportWidth-objCamera.rightBound)
        {
            x+=1;
        }
        hsp = 0;
    }
    
    //Vertical Collision
    if (y+vsp &lt;= objCamera.y+objCamera.upperBound)
    {
        //Ceiling collision
        while(y-1 &gt; objCamera.y+objCamera.upperBound)
        {
            y-=1;
        }
        vsp = 0; touchingWall=true;
    }
    if (y+vsp &gt;= objCamera.y+objCamera.viewportHeight-objCamera.lowerBound)
    {
        //Floor collision
        while(y+1 &lt; objCamera.y+objCamera.viewportHeight-objCamera.lowerBound)
        {
            y+=1;
        }
        vsp = 0;
    }
    x += hsp;
    y += vsp;
    objPlayerCapsuleHitbox.x = x;
    objPlayerCapsuleHitbox.y = y;

    //Let's shooting!
    
    if (!hasLaser)
    {
        if (keyboard_check(global.keyAction1))
        {
            if (shootDelayTimer&lt;=0 &amp;&amp; shootCounter&lt;shootCounterMax)
            {
                thisBullet = instance_create(x+hsp,y+vsp,objBullet);
                thisBullet.parentGun = id;
                shootCounter++;
                shootDelayTimer=4;
            }
            else
            {shootDelayTimer--;}
        }
        if (keyboard_check_released(global.keyAction1))
        {shootDelayTimer=0;}
    }
    else
    {
        //Laser
        if keyboard_check(global.keyAction1) &amp;&amp; laserCooldownTimer &lt;=0
        {
            laserCooldownTimer=1;
            thisLaser = instance_create(x+hsp,y+vsp-1,objLaser);
            thisLaser.laserType = 1; //Your standard gradius laser. Assume 2 is "CLaser"
            thisLaser.parentGun = id;
        }
        else if (laserCooldownTimer &gt;0)
        {laserCooldownTimer--;}
    }
    
    //Double
    if (hasDouble)
    {
        shootCounterMax=shootCounterMaxWithDouble;
        if (keyboard_check(global.keyAction1))
        {
            if (shootDoubleDelayTimer&lt;=0 &amp;&amp; shootDoubleCounter&lt;shootDoubleCounterMax)
            {
                thisBullet = instance_create(x+hsp,y+vsp,objDouble);
                thisBullet.parentGun = id;
                shootDoubleCounter++;
                shootDoubleDelayTimer=4;
            }
            else
            {shootDoubleDelayTimer--;}
        }
    }
    else{shootCounterMax=shootCounterMaxWithoutDouble}
    
    //Missile
    if (hasMissile)
    {
        if (keyboard_check(global.keyAction1))
        {
            if (missileDelayTimer&lt;=0 &amp;&amp; missileCounter&lt;missileCounterMax)
            {
                thisBullet = instance_create(x+hsp,y+vsp,objMissile);
                thisBullet.parentGun = id;
                missileCounter++;
                missileDelayTimer=4;
            }
            else
            {missileDelayTimer--;}
        }
        if (keyboard_check_released(global.keyAction1))
        {missileDelayTimer=0;}
    }

    //----Handle ship animations
    //Set the ship back to neutral position if our player isn't moving vertically or is touching a wall.
    //shipTurning is the ship-tilting animation
    
    if ((touchingWall) || (movingVert==0))
    {
        if(shipTurning&gt;0){if shipTurning-playerSpeed&gt;0{shipTurning-=playerSpeed;}else{shipTurning=0;}}
        else if(shipTurning&lt;0){if shipTurning+playerSpeed&lt;0{shipTurning+=playerSpeed;}else{shipTurning=0;}}
    }
    

    //Now we'll let the ship tilt its animation as it moves, but only if it isn't touching a wall (e.g. Camera's screen boundary)
    if(!touchingWall)
    {
        if (movingVert==-1) //Handle downward animation first
        {
            if (shipTurning-playerSpeed&lt;0)
            {
            shipTurning-=playerSpeed;
            }
            else
            {shipTurning=0;}
        }
        else if (movingVert==1)                //Now, handle the upward animation
        {
            if (shipTurning+playerSpeed&gt;0)
            {
            shipTurning+=playerSpeed;
            }
            else
            {shipTurning=0;}   
        }
    }

    //Cap values
    if (shipTurning&lt;-8*turnMult){shipTurning=-8*turnMult;}
    if (shipTurning&gt;8*turnMult){shipTurning=8*turnMult;}
    
    //Handle ship animations
    if (shipTurning &lt;-4*turnMult){image_index=4;} //Downmost
    else if (shipTurning&gt;=-4*turnMult &amp;&amp; shipTurning &lt;0){image_index=3;} //Slight Down
    else if (shipTurning&gt;0 &amp;&amp; shipTurning &lt;=4*turnMult){image_index=1;} //Slight Up
    else if (shipTurning&gt;4*turnMult){image_index=2;} //Upmost 
    else {image_index=0;} //Every other case is neutral position


    if (keyboard_check(global.keyRight) || 
        keyboard_check(global.keyLeft) || 
        keyboard_check(global.keyUp) || 
        keyboard_check(global.keyDown)) //If the player is moving at all...
    {

    //GRV-Style Option Movement code
    if (keyboard_check(global.keyAction3) &amp;&amp; global.grVOptEnabled) //Are we pushing the Option button and is the feature enabled?
    {
        if (hsp!=0)
        {
        for (var i = 39; i &gt;= 0; i--;)  //Shift all 40 frames of x/y ghost trailing by however the player moved
           {
           prevX[i] += hsp;
           }
        }
        if (vsp!=0)
        {
        for (var i = 39; i &gt;= 0; i--;)  //Shift all 40 frames of x/y ghost trailing by however the player moved
           {
            prevY[i] += vsp;
            }
        }
    }
    else //If not, we should keep track of the player's x/y positions for the past 40 frames of the game in the two arrays prevX and prevY, constantly.
    {
        //Shift all the X/Y previous positions down the bank
        for (var i = 39; i &gt; 0; i--;)
           {
           prevX[i] = prevX[i-1];
           prevY[i] = prevY[i-1];
           }
        //Finally, store X/Y in the first position
        prevX[0] = x;
        prevY[0] = y;
        }
    }

    
    //Regardless we're moving or not, update every single X/Y ghost position with the camera scrolling
    for (var i = 39; i &gt;= 0; i--;)
       {
       prevX[i] += objCamera.scrollX;
       prevY[i] += objCamera.scrollY;
       }

    
    //Handle the flame burning animation index at the end of the ship, based on our player's speed
    
    var flameImgOut=0; //Temporary variable for storing animation index before actually outputting it to the screen
    
    if (global.tick%flameSpeed==0) //Hop between animation frames (lazily using a boolean) so the fire looks more lively
    {
        flameIn = !flameIn;
    }
    
    switch(playerSpeed) //Determine the first frame of the flame animation, depending on the player's speed
    {
        case 1: flameImgOut=0; break; //In the event that the playerSpeed is 1, start our animation on frame 0
        case 2: flameImgOut=2; break; //etc...
        case 3: flameImgOut=2; break;
        case 4: flameImgOut=4; break;
        case 5: flameImgOut=4; break;
        default: flameImgOut=4; break; //In the event our player speed is some weird value, default to frame 4
    }
    
    flameImgOut+=flameIn;
    
    flameImgInd=flameImgOut; //Finally, we store the flame animation, which is then drawn in objCamera's Draw event
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle powerups
//The HUD itself is drawn in objCamera's Draw Event

if (objCamera.debug)
{
    if keyboard_check_pressed(ord('T'))
    {
        powerupSlot+=1; //Give us a powerup capsule if we press T on the keyboard
    }
    if (keyboard_check_pressed(ord('U')))
    {
        objPlayer.konDone = false;
        objPlayer.konCode = true;
    }
    
    if (keyboard_check_pressed(ord('G')))
    {
        global.playerScore += 500;
    }
    if (keyboard_check_pressed(ord('B')))
    {
        dead = true;
    }
    if (keyboard_check_pressed(ord('I')))
    {
        if (playerSpeed&lt;playerSpeedMax)
            {
            playerSpeed+=1; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
    }
    if (keyboard_check_pressed(ord('O')))
    {if instance_exists(objFrontShield){objFrontShield.HP--;}}
}

if (konCode &amp;&amp; !konDone &amp;&amp; (konCodeLimit&gt;0 || callD&gt;0))
{
    hasMissile = true;
    hasDouble = false;
    hasLaser = true;
    while(numOfOpts&lt;optsMax) //Continue to give the player an Option until they've hit the max
    {
        instance_create(-5000,-5000,objOption); //Spawn a new Option far away
        numOfOpts+=1;
    }
    
    if instance_exists(objFrontShield)
    {
        with(objFrontShield)
        {instance_destroy();}
    }
    hasQuestion = true;
    shield1 = instance_create(objCamera.x+288,objCamera.y-32,objFrontShield);
    shield1.xDest = 16;
    shield1.yDest = -8;
    shield2 = instance_create(objCamera.x+288,objCamera.y+objCamera.viewportHeight+32,objFrontShield);
    shield2.xDest = 16;
    shield2.yDest = 8;
    konDone = true;
}

if (instance_number(objFrontShield)&lt;=0)
{
    hasQuestion = false;
}

//Wrap around if we go too far beyond the powerup HUD
if (powerupSlot&gt;7)
{
    powerupSlot = 1;
}

//Mega crash only needs one frame, then it's disabled again
hasExclamation = false;

if keyboard_check_pressed(global.keyAction2) &amp;&amp; !objPlayer.dead &amp;&amp; (objCamera.debug || global.state=states.gameMode)  //Attempt to give powerup after pressing equip button
{
    switch(powerupSlot) //Check the value of our powerup's position and, depending what it is, try giving a powerup
    {
        case 1: //Speedup
            if (playerSpeed&lt;playerSpeedMax)
            {
            playerSpeed+=1;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 2: //Missile
            if (!hasMissile)
            {
            hasMissile = true;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 3: //Double
            if (!hasDouble)
            {
            hasDouble = true;
            hasLaser = false;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 4: //Laser
            if (!hasLaser)
            {
            hasLaser = true;
            hasDouble = false;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 5: //Option
            if (numOfOpts&lt;optsMax)
            {
            numOfOpts+=1;instance_create(-5000,-5000,objOption); //Spawn a new Option far away
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 6: //Question
            if (!hasQuestion)
            {
            hasQuestion = true;
            shield1 = instance_create(objCamera.x+288,objCamera.y-32,objFrontShield);
            shield1.xDest = 16;
            shield1.yDest = -8;
            shield2 = instance_create(objCamera.x+288,objCamera.y+objCamera.viewportHeight+32,objFrontShield);
            shield2.xDest = 16;
            shield2.yDest = 8;
            powerupSlot = 0; audio_stop_sound(sfxMenuAccept); audio_play_sound(sfxMenuAccept,0,false);
            }
            break;
        case 7: //Exclamation
            if (!hasExclamation)
            {
            hasExclamation = true;
            excTimer = 10;
            powerupSlot = 0; audio_stop_sound(sfxMCrash); audio_play_sound(sfxMCrash,0,false);
            }
            break;
        default: break;
    }
}

if (excTimer&gt;0){excTimer--;}

if (callD&gt;0){fun=true;}
if (global.state==states.gameMode)
{
    if (callD&gt;-1 &amp;&amp; fun){callD--;}
    if (callD&lt;=-1){dead=true;}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
